import usysimport ustruct as structimport utimefrom machine import Pin, SPI, ADC, I2Cfrom ssd1306 import SSD1306_I2Cfrom nrf24l01 import NRF24L01from micropython import constfrom buzzer_music import music# Slave pause between receiving data and checking for further packets._RX_POLL_DELAY = const(15)# Slave pauses an additional _SLAVE_SEND_DELAY ms after receiving data and before# transmitting to allow the (remote) master time to get into receive mode. The# master may be a slow device._SLAVE_SEND_DELAY = const(10)#collection of alarm soundssongs = ('0 C7 4 13;12 B6 4 13;16 C7 4 13;28 B6 4 13;4 C7 4 13;8 B6 4 13;20 C7 4 13;24 B6 4 13', '44 B7 4 13;40 A7 4 13;36 G7 4 13;32 F7 4 13;28 D#7 4 13;24 C#7 4 13;20 B6 4 13;16 A6 4 13;12 G6 4 13;8 F6 4 13;4 D#6 4 13;0 C#6 4 13','0 E4 4 13;28 A5 4 13;20 A6 4 13;32 A#4 4 13;24 A#4 4 13;4 F#7 4 13;12 C#7 4 13;8 A4 4 13;44 A6 4 13;40 C#7 4 13;32 F#7 4 13;16 C#5 4 13')#use GPIO15 for a reset button to shut off the alarmbtn_reset = Pin(10, Pin.IN)#use GPIO16 for the buzzeralarm_pin = Pin(16, Pin.OUT)if usys.platform == "rp2":  # PI PICO    cfg = {"spi": 0, "miso": 4, "mosi": 7, "sck": 6, "csn": 14, "ce": 17}else:    raise ValueError("Unsupported platform {}".format(usys.platform))pipes = (b"\xe1\xf0\xf0\xf0\xf0", b"\xd2\xf0\xf0\xf0\xf0")#basic parameters for the displaywidth = 64height = 32#use GPIO18 and GPIO19 as SDA and SCL pins to create an instance of the I2C busi2c=I2C(0,sda=Pin(0), scl=Pin(1), freq=200000 )#create an instance of the SSD1306 displaydisplay = SSD1306_I2C(width, height, i2c)def slave():    csn = Pin(cfg["csn"], mode=Pin.OUT, value=1)    ce = Pin(cfg["ce"], mode=Pin.OUT, value=0)    if cfg["spi"] == 0:        spi = SPI(0, sck=Pin(cfg["sck"]), mosi=Pin(cfg["mosi"]), miso=Pin(cfg["miso"]))        nrf = NRF24L01(spi, csn, ce, payload_size=32)    else:        nrf = NRF24L01(SPI(cfg["spi"]), csn, ce, payload_size=32)    nrf.open_tx_pipe(pipes[1])    nrf.open_rx_pipe(1, pipes[0])    nrf.start_listening()    print("NRF24L01 slave mode, waiting for packets... (ctrl-C to stop)")    display.text("ALARM", 0,0)    display.text("ARMED", 0,16)    display.show()    while True:        display.fill(0)        display.show()        display.text("ALARM", 0,0)        display.text("ARMED", 0,16)        display.show()        if nrf.any():            while nrf.any():                buf = nrf.recv()                alarm_state, pot_value = struct.unpack("ii", buf)                print("received:", alarm_state, pot_value)            # Give master time to get into receive mode.            utime.sleep_ms(_SLAVE_SEND_DELAY)            nrf.stop_listening()            try:                nrf.send(struct.pack("i", 1)) #let other side know their message arrived            except OSError:                pass            print("sent response")            if alarm_state == 1:                #prepare the alarm song                alarm_sound = map(pot_value,224,65535,0,2)                mySong = music(songs[alarm_sound], pins=[alarm_pin])                                #clear display                display.fill(0)                display.show()                                #write text to display                alarm_text1 = "I see"                alarm_text2 = " you!"                alarm_text3 = "alarm:" + str(alarm_sound)                display.text(alarm_text1, 0, 0) #String, x coordinate, y coordinate                display.text(alarm_text2,0,13)                display.text(alarm_text3,0,25)                display.show()                                #keep playing until alarm gets reset                reset = btn_reset.value()                while not reset:                    reset = btn_reset.value()                    mySong.tick()                    utime.sleep_ms(40)                else:                    #get back into receiver mode                    print("resetting")                    mySong.stop()                    nrf.start_listening()                                #delay then loop            utime.sleep_ms(250)#function for remapping values, 16 bit naar 12bit naar rangedef map(value, in_min, in_max, out_min, out_max):  mapped_value = ((value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min)  return round(mapped_value)